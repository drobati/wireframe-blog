<style>
    #book-detail-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 200;
        background: rgba(0, 0, 0, 0.4);
        justify-content: center;
        align-items: center;
    }
    #book-detail-overlay.active {
        display: flex;
    }
    #book-detail-panel {
        background: #fdf6e3;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 28px 32px;
        max-width: 480px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        font-family: 'DM Sans', sans-serif;
        position: relative;
        box-shadow: 4px 4px 0 rgba(0,0,0,0.15);
    }
    #book-detail-panel .close-btn {
        position: absolute;
        top: 10px;
        right: 14px;
        font-size: 1.5em;
        cursor: pointer;
        background: none;
        border: none;
        font-family: inherit;
        line-height: 1;
    }
    #book-detail-panel h2 {
        margin: 0 0 4px 0;
        font-size: 1.3em;
        padding-right: 30px;
    }
    #book-detail-panel .author {
        color: #666;
        margin: 0 0 12px 0;
        font-size: 0.95em;
    }
    #book-detail-panel .meta {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 12px;
        font-size: 0.85em;
    }
    #book-detail-panel .meta span {
        background: rgba(0,0,0,0.06);
        padding: 2px 8px;
        border-radius: 4px;
    }
    #book-detail-panel .description {
        font-size: 0.85em;
        line-height: 1.5;
        color: #444;
    }
    #scroll-hint {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        font-family: 'DM Sans', sans-serif;
        font-size: 0.85em;
        color: rgba(80, 60, 30, 0.6);
        pointer-events: none;
        transition: opacity 0.5s;
    }
</style>

<div id="book-detail-overlay">
    <div id="book-detail-panel">
        <button class="close-btn">&times;</button>
        <h2 id="detail-title"></h2>
        <p class="author" id="detail-author"></p>
        <div class="meta">
            <span id="detail-rating"></span>
            <span id="detail-status"></span>
        </div>
        <div class="description" id="detail-description"></div>
    </div>
</div>

<div id="scroll-hint">&#8592; scroll to browse &#8594;</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.170.0/build/three.module.js';

// --- Constants ---
const BOOK_COLORS = {
    darkgreen:    0x006400,
    green:        0x4CAF50,
    darkblue:     0x0C347D,
    umber:        0x54290C,
    springer:     0xEDED80,
    red:          0xd34949,
    lightblue:    0x4A90E2,
    brightorange: 0xffd890,
};
const COLOR_KEYS = Object.keys(BOOK_COLORS);
const LIGHT_TEXT_COLORS = new Set(['springer', 'brightorange']); // these get dark text

const BOOK_DEPTH = 0.8;
const BOOK_GAP = 0.06;
const SHELF_Y = -0.15;
const SHELF_DEPTH = 1.2;
const SHELF_THICKNESS = 0.15;
const BACK_PANEL_HEIGHT = 3.5;

const TILT_INTERVAL = 15;
const TILT_ANGLE = 9 * (Math.PI / 180);

// --- Setup renderer ---
const canvas = document.getElementById('bookshelf-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

// --- Scene ---
const scene = new THREE.Scene();
// No scene background — transparent canvas blends with page

// --- Camera ---
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 1.25, 4.0);
camera.lookAt(0, 1.25, 0);

// --- Lights ---
const ambient = new THREE.AmbientLight(0xfff5e0, 0.9);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(4, 6, 3);
scene.add(dirLight);

// --- Helpers ---
function hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return Math.abs(hash);
}

function seededRandom(seed) {
    let s = seed;
    return function() {
        s = (s * 16807 + 0) % 2147483647;
        return s / 2147483647;
    };
}

// --- Build book data ---
const rawBooks = typeof BOOKS !== 'undefined' ? BOOKS : [];
const bookMeshes = [];
let totalWidth = 0;

// Sort by author, with series grouped together by sequence within each author
const entries = rawBooks.map((b, i) => ({ book: b, origIndex: i }));

// Group series and sort each group by sequence
const seriesGroups = {};
for (const entry of entries) {
    const key = entry.book.series_name;
    if (!key) continue;
    if (!seriesGroups[key]) seriesGroups[key] = [];
    seriesGroups[key].push(entry);
}
for (const group of Object.values(seriesGroups)) {
    group.sort((a, b) => {
        const sa = parseFloat(a.book.series_sequence) || 999;
        const sb = parseFloat(b.book.series_sequence) || 999;
        return sa - sb;
    });
}

// Group all books by author
const authorGroups = {};
for (const entry of entries) {
    const author = (entry.book.author || 'Unknown').trim();
    if (!authorGroups[author]) authorGroups[author] = [];
    authorGroups[author].push(entry);
}

// Within each author: series books (grouped + sequence-sorted) first, then standalones
const sortedEntries = [];
for (const author of Object.keys(authorGroups).sort()) {
    const authorEntries = authorGroups[author];
    // Emit series groups in order of first appearance within this author
    const seenInAuthor = new Set();
    const seriesForAuthor = [];
    const standalone = [];
    for (const entry of authorEntries) {
        if (entry.book.series_name) {
            if (!seenInAuthor.has(entry.book.series_name)) {
                seenInAuthor.add(entry.book.series_name);
                seriesForAuthor.push(...seriesGroups[entry.book.series_name]);
            }
        } else {
            standalone.push(entry);
        }
    }
    sortedEntries.push(...seriesForAuthor, ...standalone);
}
const books = sortedEntries.map(e => e.book);

// Pre-compute series dimensions (shared width, height, color per series)
const seriesDims = {};
for (const [name] of Object.entries(seriesGroups)) {
    const rng = seededRandom(hashCode(name));
    seriesDims[name] = {
        width: 0.20 + rng() * 0.20,  // 0.20 to 0.40
        height: 2.2 + rng() * 0.5,   // 2.2 to 2.7
        colorKey: COLOR_KEYS[hashCode(name) % COLOR_KEYS.length],
    };
}

// Pre-calculate positions and dimensions
const bookData = books.map((book, i) => {
    const series = book.series_name ? seriesDims[book.series_name] : null;
    const rng = seededRandom(hashCode(book.title || `book${i}`));
    const width = series ? series.width : 0.15 + rng() * 0.30;
    const height = series ? series.height : 2.0 + rng() * 0.8;
    const colorKey = series ? series.colorKey : COLOR_KEYS[hashCode(book.title || `book${i}`) % COLOR_KEYS.length];
    // Don't tilt books that are part of a series (keeps groups uniform)
    const isTilted = !series && (i % TILT_INTERVAL === (TILT_INTERVAL - 1)) && i > 0;
    const tiltExtra = isTilted ? 0.35 : 0;
    return { book, width, height, colorKey, isTilted, tiltExtra, index: i };
});

// Calculate cumulative x positions
const bookPositions = [];
let x = 0;
for (const bd of bookData) {
    bookPositions.push(x + bd.width / 2 + bd.tiltExtra / 2);
    x += bd.width + BOOK_GAP + bd.tiltExtra;
}
totalWidth = x;

// --- Shared noise tile (generated once, tiled onto spines/covers) ---
const NOISE_TILE_SIZE = 64;
const NOISE_TILE = document.createElement('canvas');
NOISE_TILE.width = NOISE_TILE_SIZE;
NOISE_TILE.height = NOISE_TILE_SIZE;
const _nctx = NOISE_TILE.getContext('2d');
const _ndata = _nctx.createImageData(NOISE_TILE_SIZE, NOISE_TILE_SIZE);
const _nrng = seededRandom(42);
for (let i = 0; i < _ndata.data.length; i += 4) {
    const v = Math.floor(_nrng() * 255);
    _ndata.data[i] = v;
    _ndata.data[i + 1] = v;
    _ndata.data[i + 2] = v;
    _ndata.data[i + 3] = 22;
}
_nctx.putImageData(_ndata, 0, 0);

function addNoise(ctx, x, y, w, h) {
    ctx.save();
    ctx.globalCompositeOperation = 'overlay';
    const pat = ctx.createPattern(NOISE_TILE, 'repeat');
    ctx.fillStyle = pat;
    ctx.fillRect(x, y, w, h);
    ctx.restore();
}

// --- Create spine text textures ---
function createSpineTexture(title, author, height, colorKey) {
    const canvasEl = document.createElement('canvas');
    const S = 5;
    const texW = 64 * S;
    const texH = 512 * S;
    canvasEl.width = texW;
    canvasEl.height = texH;
    const ctx = canvasEl.getContext('2d');

    // Fill background with book color
    const hexColor = '#' + BOOK_COLORS[colorKey].toString(16).padStart(6, '0');
    ctx.fillStyle = hexColor;
    ctx.fillRect(0, 0, texW, texH);

    // Binding noise texture
    addNoise(ctx, 0, 0, texW, texH);

    // Subtle edge shading for depth
    ctx.fillStyle = 'rgba(255,255,255,0.13)';
    ctx.fillRect(0, 0, 3 * S, texH);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(texW - 3 * S, 0, 3 * S, texH);

    const isLight = LIGHT_TEXT_COLORS.has(colorKey);
    const textColor = isLight ? '#1a1a1a' : '#ffffff';
    const shadowColor = isLight ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.45)';
    const pad = 30 * S;

    // --- Title (top-to-bottom, starting from top of spine) ---
    ctx.save();
    ctx.translate(texW / 2, pad);
    ctx.rotate(Math.PI / 2);

    const titleSize = 22 * S;
    ctx.font = `700 ${titleSize}px "Outfit", sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    const authorBlockH = author ? 100 * S : 0;
    const maxTitleWidth = texH - pad * 2 - authorBlockH;

    let displayTitle = title || 'Untitled';
    if (ctx.measureText(displayTitle).width > maxTitleWidth) {
        while (ctx.measureText(displayTitle + '...').width > maxTitleWidth && displayTitle.length > 0) {
            displayTitle = displayTitle.slice(0, -1);
        }
        displayTitle += '...';
    }

    ctx.fillStyle = shadowColor;
    ctx.fillText(displayTitle, 0, 2 * S);
    ctx.fillStyle = textColor;
    ctx.fillText(displayTitle, 0, 0);
    ctx.restore();

    // --- Author (stacked words, each rotated 90° top-to-bottom, centered in bottom block) ---
    if (author) {
        let words = author.split(/\s+/);
        if (words.length > 3) {
            words = [words[0], words.slice(1).join(' ')];
        }

        const authorFontSize = 13 * S;
        const lineW = authorFontSize * 1.3; // each word takes this much horizontal space
        const blockW = words.length * lineW;
        // Center the stacked block horizontally on the spine
        const blockStartX = (texW - blockW) / 2 + lineW / 2;

        // Measure max word width (which maps to vertical space after rotation)
        ctx.font = `500 ${authorFontSize}px "Outfit", sans-serif`;
        let maxWordPx = 0;
        const displayWords = words.map(word => {
            const maxW = authorBlockH - 20 * S;
            if (ctx.measureText(word).width > maxW) {
                while (ctx.measureText(word + '.').width > maxW && word.length > 1) {
                    word = word.slice(0, -1);
                }
                word += '.';
            }
            maxWordPx = Math.max(maxWordPx, ctx.measureText(word).width);
            return word;
        });

        // Position: bottom of spine, block anchored to bottom edge
        const blockTopY = texH - pad - maxWordPx;

        ctx.fillStyle = isLight ? 'rgba(0,0,0,0.5)' : 'rgba(255,255,255,0.6)';
        for (let w = 0; w < displayWords.length; w++) {
            ctx.save();
            // Each word centered in its column, rotated to read top-to-bottom
            ctx.translate(blockStartX + w * lineW, texH - pad);
            ctx.rotate(Math.PI / 2);
            ctx.font = `500 ${authorFontSize}px "Outfit", sans-serif`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(displayWords[w], 0, 0);
            ctx.restore();
        }
    }

    const texture = new THREE.CanvasTexture(canvasEl);
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
    return texture;
}

// --- Create cover texture with binding bleed ---
// bleedEdge: 'left' or 'right' — which edge gets the noise strip
function createCoverTexture(colorKey, bleedEdge) {
    const canvasEl = document.createElement('canvas');
    const w = 256;
    const h = 512;
    canvasEl.width = w;
    canvasEl.height = h;
    const ctx = canvasEl.getContext('2d');

    const hexColor = '#' + BOOK_COLORS[colorKey].toString(16).padStart(6, '0');
    ctx.fillStyle = hexColor;
    ctx.fillRect(0, 0, w, h);

    // Noise strip on the binding edge (~10% of width), fading out
    const bleedW = Math.round(w * 0.12);
    const bleedX = bleedEdge === 'right' ? w - bleedW : 0;

    // Draw noise at full strength on the edge, fading inward
    for (let step = 0; step < bleedW; step++) {
        const t = bleedEdge === 'right' ? step / bleedW : 1 - step / bleedW;
        const alpha = (1 - t) * 0.6; // strongest at spine edge, fades to 0
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.globalCompositeOperation = 'overlay';
        const pat = ctx.createPattern(NOISE_TILE, 'repeat');
        ctx.fillStyle = pat;
        ctx.fillRect(bleedX + step, 0, 1, h);
        ctx.restore();
    }

    const texture = new THREE.CanvasTexture(canvasEl);
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
    return texture;
}

// --- Create book meshes ---
for (let i = 0; i < bookData.length; i++) {
    const bd = bookData[i];
    const geom = new THREE.BoxGeometry(bd.width, bd.height, BOOK_DEPTH);
    const color = BOOK_COLORS[bd.colorKey];

    const spineTexture = createSpineTexture(bd.book.binding_title || bd.book.title_short || bd.book.title, bd.book.author, bd.height, bd.colorKey);

    // Cover textures with binding bleed from spine edge
    // +x face: spine is at u=1 (right edge), so bleed on right
    // -x face: spine is at u=0 (left edge), so bleed on left
    const rightCoverTex = createCoverTexture(bd.colorKey, 'right');
    const leftCoverTex = createCoverTexture(bd.colorKey, 'left');

    // Materials: [+x, -x, +y, -y, +z (front/spine), -z (back)]
    const baseMat = new THREE.MeshStandardMaterial({ color, roughness: 0.75, metalness: 0.05 });
    const spineMat = new THREE.MeshStandardMaterial({ map: spineTexture, roughness: 0.8, metalness: 0.03 });
    const rightCoverMat = new THREE.MeshStandardMaterial({ map: rightCoverTex, roughness: 0.75, metalness: 0.05 });
    const leftCoverMat = new THREE.MeshStandardMaterial({ map: leftCoverTex, roughness: 0.75, metalness: 0.05 });
    const materials = [
        rightCoverMat, // right (+x)
        leftCoverMat,  // left (-x)
        baseMat,       // top
        baseMat,       // bottom
        spineMat,      // front (facing camera = spine)
        baseMat,       // back
    ];

    const mesh = new THREE.Mesh(geom, materials);
    const bx = bookPositions[i];
    const by = SHELF_Y + SHELF_THICKNESS / 2 + bd.height / 2;
    mesh.position.set(bx, by, 0);

    if (bd.isTilted) {
        mesh.rotation.z = TILT_ANGLE;
        // Raise book so the lowest corner still sits on the shelf surface
        const dropFromTilt = (bd.width / 2) * Math.sin(TILT_ANGLE) - (bd.height / 2) * (1 - Math.cos(TILT_ANGLE));
        mesh.position.y += dropFromTilt;
    }

    mesh.userData = { bookIndex: i, originalScale: new THREE.Vector3(1, 1, 1), baseY: mesh.position.y };
    scene.add(mesh);
    bookMeshes.push(mesh);
}

// --- Shelf ---
const shelfGeom = new THREE.BoxGeometry(totalWidth + 4, SHELF_THICKNESS, SHELF_DEPTH);
const shelfMat = new THREE.MeshStandardMaterial({ color: 0x8B5E3C, roughness: 0.85, metalness: 0.05 });
const shelf = new THREE.Mesh(shelfGeom, shelfMat);
shelf.position.set(totalWidth / 2, SHELF_Y, 0);
scene.add(shelf);

// --- Back panel (removed — transparent canvas shows page background) ---
const backPanel = { position: { x: 0 } }; // stub so wrapBooks() doesn't break

// --- Scroll state ---
let scrollOffset = 0;
let scrollVelocity = 0;
const FRICTION = 0.92;
const SCROLL_SPEED = 0.003;
let isDragging = false;
let lastPointerX = 0;

// Center camera initially on middle of shelf
scrollOffset = totalWidth / 2;
camera.position.x = scrollOffset;

// --- Infinite wrapping ---
function wrapBooks() {
    const halfTotal = totalWidth / 2;
    const viewCenter = camera.position.x;

    for (let i = 0; i < bookMeshes.length; i++) {
        const mesh = bookMeshes[i];
        const baseX = bookPositions[i];

        // Find closest wrapped position to camera
        let wx = baseX;
        while (wx - viewCenter > halfTotal) wx -= totalWidth;
        while (wx - viewCenter < -halfTotal) wx += totalWidth;
        mesh.position.x = wx;
    }

    // Also wrap shelf and back panel (make them very wide so gaps aren't visible)
    shelf.position.x = viewCenter;
    backPanel.position.x = viewCenter;
}

// --- Scroll events ---
canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    // Support both vertical scroll (mouse wheel) and horizontal swipe (trackpad)
    const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
    scrollVelocity += delta * SCROLL_SPEED;
}, { passive: false });

// Touch support
canvas.addEventListener('touchstart', (e) => {
    isDragging = true;
    lastPointerX = e.touches[0].clientX;
    scrollVelocity = 0;
}, { passive: true });

canvas.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.touches[0].clientX;
    const delta = lastPointerX - x;
    scrollVelocity = delta * 0.02;
    scrollOffset += delta * 0.015;
    lastPointerX = x;
}, { passive: false });

canvas.addEventListener('touchend', () => {
    isDragging = false;
});

// Mouse drag support
canvas.addEventListener('mousedown', (e) => {
    // Only start drag if not clicking a book (handled by click)
    isDragging = true;
    lastPointerX = e.clientX;
    scrollVelocity = 0;
});

canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const x = e.clientX;
    const delta = lastPointerX - x;
    scrollVelocity = delta * 0.02;
    scrollOffset += delta * 0.015;
    lastPointerX = x;
});

canvas.addEventListener('mouseup', () => {
    isDragging = false;
});

// --- Raycaster for hover/click ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredMesh = null;
let mouseDownPos = new THREE.Vector2();

canvas.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});

canvas.addEventListener('mousedown', (e) => {
    mouseDownPos.set(e.clientX, e.clientY);
});

canvas.addEventListener('click', (e) => {
    // Ignore if it was a drag
    const dist = Math.sqrt(
        Math.pow(e.clientX - mouseDownPos.x, 2) +
        Math.pow(e.clientY - mouseDownPos.y, 2)
    );
    if (dist > 5) return;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(bookMeshes);
    if (intersects.length > 0) {
        const mesh = intersects[0].object;
        const bookIndex = mesh.userData.bookIndex;
        showBookDetail(books[bookIndex]);
    }
});

// --- Hover effect (tilt book toward viewer) ---
const HOVER_TILT = 12 * (Math.PI / 180); // tilt angle on X-axis
const HOVER_LIFT = 0.15; // lift up so bottom clears shelf
const HOVER_PULL = 0.4;  // pull toward camera
function updateHover() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(bookMeshes);

    if (hoveredMesh && (!intersects.length || intersects[0].object !== hoveredMesh)) {
        // Un-hover: restore rotation, position, scale
        hoveredMesh.rotation.x = 0;
        hoveredMesh.position.y = hoveredMesh.userData.baseY;
        hoveredMesh.position.z = 0;
        hoveredMesh.scale.copy(hoveredMesh.userData.originalScale);
        hoveredMesh = null;
        canvas.style.cursor = 'default';
    }

    if (intersects.length > 0 && !isDragging) {
        const mesh = intersects[0].object;
        if (mesh !== hoveredMesh) {
            hoveredMesh = mesh;
            // Tilt toward viewer, lift up to clear shelf, pull forward
            mesh.rotation.x = -HOVER_TILT;
            mesh.position.y = mesh.userData.baseY + HOVER_LIFT;
            mesh.position.z = HOVER_PULL;
            canvas.style.cursor = 'pointer';
        }
    }
}

// --- Book detail panel ---
const overlay = document.getElementById('book-detail-overlay');
const detailTitle = document.getElementById('detail-title');
const detailAuthor = document.getElementById('detail-author');
const detailRating = document.getElementById('detail-rating');
const detailStatus = document.getElementById('detail-status');
const detailDescription = document.getElementById('detail-description');
const closeBtn = overlay.querySelector('.close-btn');

function showBookDetail(book) {
    detailTitle.textContent = book.title || 'Untitled';
    detailAuthor.textContent = book.author || 'Unknown Author';

    const rating = parseFloat(book.rating_average);
    detailRating.textContent = isNaN(rating) ? '' : `${'★'.repeat(Math.round(rating))}${'☆'.repeat(5 - Math.round(rating))} ${rating.toFixed(1)}`;
    detailStatus.textContent = book.read_status || '';

    // Strip HTML tags from description for clean display
    const tmp = document.createElement('div');
    tmp.innerHTML = book.description || book.summary || 'No description available.';
    detailDescription.textContent = tmp.textContent;

    overlay.classList.add('active');
}

function hideBookDetail() {
    overlay.classList.remove('active');
}

closeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    hideBookDetail();
});

overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
        hideBookDetail();
    }
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') hideBookDetail();
});

// --- Scroll hint ---
const scrollHint = document.getElementById('scroll-hint');
let hintTimeout = setTimeout(() => {
    if (scrollHint) scrollHint.style.opacity = '0';
}, 4000);

function onFirstScroll() {
    if (scrollHint) scrollHint.style.opacity = '0';
    canvas.removeEventListener('wheel', onFirstScroll);
    canvas.removeEventListener('touchstart', onFirstScroll);
}
canvas.addEventListener('wheel', onFirstScroll);
canvas.addEventListener('touchstart', onFirstScroll);

// --- Resize ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});

// --- Animate ---
function animate() {
    requestAnimationFrame(animate);

    // Apply momentum
    if (!isDragging) {
        scrollOffset += scrollVelocity;
        scrollVelocity *= FRICTION;
        if (Math.abs(scrollVelocity) < 0.0001) scrollVelocity = 0;
    }

    camera.position.x = scrollOffset;
    camera.lookAt(scrollOffset, 1.25, 0);

    wrapBooks();
    updateHover();

    renderer.render(scene, camera);
}

// Wait for font to load before rendering textures
document.fonts.ready.then(() => {
    // Re-create textures with loaded font
    for (let i = 0; i < bookData.length; i++) {
        const bd = bookData[i];
        const newTexture = createSpineTexture(bd.book.binding_title || bd.book.title_short || bd.book.title, bd.book.author, bd.height, bd.colorKey);
        bookMeshes[i].material[4].map = newTexture;
        bookMeshes[i].material[4].needsUpdate = true;
    }
    animate();
});
</script>
